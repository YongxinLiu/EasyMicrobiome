#!/usr/bin/env Rscript

# Copyright 2024 De-feng Bai <baidefeng@caas.cn>

# If used this script, please cited:
# Yong-Xin Liu, Yuan Qin, Tong Chen, Meiping Lu, Xubo Qian, Xiaoxuan Guo, et al. 2021. A practical guide to amplicon and metagenomic analysis of microbiome data. Protein & Cell 12: 315-330. https://doi.org/10.1007/s13238-020-00724-8

# 手动运行脚本，使用 Ctrl+Shift+H 或 Session 需要设置工作目录
# Set Work Directory - Choose Directory / To Source File Location

# Clean enviroment object
rm(list=ls()) 

# 1.1 简介 Introduction #----

# 程序功能：运用MaAsLin2方法计算组间差异
# Functions: Difference analysis using MaAsLin2


options(warn = -1) # Turn off warning

# 1.2 参数 Parameters #----
# 设置清华源加速下载
# (Optional) Set up Tsinghua Mirror to speed up download
site="https://mirrors.tuna.tsinghua.edu.cn/CRAN"
# 判断命令行解析包是否安装，没安装则安装，然后加载
# Determine whether the command line parsing package is installed, install it if it is not installed, then load
if (!suppressWarnings(suppressMessages(require("optparse", character.only = TRUE, quietly = TRUE, warn.conflicts = FALSE)))) {
  install.packages("optparse", repos=site)
  require("optparse",character.only=T)
}
# 解析参数-h显示帮助信息
if (TRUE){
  option_list = list(
    make_option(c("-i", "--input"), type="character", default="result12/metaphlan4/Species.txt",
                help="Unfiltered OTU table [default %default]"),
    make_option(c("-g", "--metadata"), type="character", default="result12/metadata.txt",
                help="metadata file or metadata [default %default]"),
    make_option(c("-o", "--output"), type="character", default="result12/metaphlan4/",
                help="Output quantile value for filter feature table [default %default]") 
  )
  opts = parse_args(OptionParser(option_list=option_list))
}
print("You are using the following parameters:")
print(opts)

# Version 1.0, Based on ASV table and taxonomy, output well info (purity, counts and taxonomy) and candidate wells of non-redundancy ASV
# 版本 1.0, 基于ASV表和7级物种注释文件，输出每个孔的信息，筛选每个孔的信息()，以及非冗余ASV的修行孔，纯度优先，数据量其次排序的Top 5


# Install related packages
# 基于CRAN安装R包，检测没有则安装 Installing R packages based on CRAN and installing them if they are not detected
p_list = c("dplyr", "reshape2",  "readxl", "phyloseq", "tibble",  "openxlsx",
           "foreach", "data.table",  "gridExtra", "scales", "ggplot2",  "ggh4x",
           "ggfortify", "ggvenn",  "ggrepel", "vegan", "pairwiseCI",  "vcd",
           "ANCOMBC", "Maaslin2",  "igraph")
for(p in p_list){if (!requireNamespace(p)){install.packages(p)}
  library(p, character.only = TRUE, quietly = TRUE, warn.conflicts = FALSE)}

#### LOAD REQUIRED R PACKAGES ####
suppress <- function(x){invisible(capture.output(suppressMessages(suppressWarnings(x))))}

suppress(library(dplyr))
suppress(library(reshape2))
suppress(library(readxl))
suppress(library(phyloseq))
suppress(library(tibble))
suppress(library(openxlsx))
suppress(library(foreach))
suppress(library(data.table))
suppress(library(gridExtra))
suppress(library(scales))
suppress(library(ggplot2))
suppress(library(ggh4x))
suppress(library(ggfortify))
suppress(library(ggvenn))
suppress(library(ggrepel))
suppress(library(vegan))
suppress(library(pairwiseCI))
suppress(library(vcd))
suppress(library(ANCOMBC))
suppress(library(Maaslin2))
suppress(library(igraph))


#### PREPARE RELATIVE ABUNDANCE AND COUNT DATA ####
#metadata <- data.frame(read_xlsx('data/source_data_npc779_89.xlsx', sheet='subject_metadata'))
metadata <- read.delim(opts$metadata, header=T, sep="\t")
#metadata <- data.frame(read_xlsx('data3/source_data_npc779_89_2.xlsx', sheet='subject_metadata'))
rownames(metadata) <- metadata$SampleID

# read in tables that were previously generated by taxonomic profiling
#ra <- data.frame(read_xlsx('data/source_data_npc779_89.xlsx', sheet='metaphlan_rel_ab2'))
ra <- read.delim(opts$input, header=T, sep="\t")
ra <- ra[,c('Taxonomy',metadata$SampleID)]

# make table sample x feature
rownames(ra) <- ra$Taxonomy
ra <- data.frame(t(ra[,-1]), check.names=FALSE)
#ra <- ra[, c(-1,-2)]

# compile relative abundance data into phyloseq objects for species
ra.sub <- ra
ra.ps.s <- phyloseq(otu_table(as.matrix(ra.sub), taxa_are_rows=FALSE),
                    sample_data(metadata),
                    tax_table(as.matrix(
                      data.frame(Taxonomy = colnames(ra.sub),
                                 check.names=FALSE, row.names=colnames(ra.sub)))))

## Group 
sample_data(ra.ps.s)$Group <- dplyr::recode(sample_data(ra.ps.s)$Group, 
                                                  `Cancer`=1, Normal=2)

# lm.s.npc
library(phyloseq)
library(Maaslin2)
ci <- function(coef, se){
  lower.ci <- coef - 1.96*se
  upper.ci <- coef + 1.96*se
  return(c(lower.ci=lower.ci,upper.ci=upper.ci))
}

ps = phyloseq(otu_table(ra.ps.s)/100, sample_data(ra.ps.s))
#ps = phyloseq(otu_table(ra.ps.s), sample_data(ra.ps.s))
# run MaAsLin2
input_data <- data.frame(otu_table(ps))
library(sampling)
sam_data = as.data.frame(sample_data(ps))
common_columns = colnames(sam_data)[colnames(sam_data) %in% colnames(metadata)]
input_metadata <- data.frame(sam_data[, common_columns])
capt<- capture.output(fits <- suppressWarnings(Maaslin2(input_data, input_metadata, 
                                                        output='temp_directory', 
                                                        min_prevalence=0.05, 
                                                        #min_variance,
                                                        #normalization='NONE', 
                                                        normalization='CLR',
                                                        #normalization= 'TSS',
                                                        #transform='LOG',
                                                        transform = "NONE",
                                                        correction = "BH",
                                                        analysis_method='LM',
                                                        max_significance=0.05,
                                                        fixed_effects = c('Group'),
                                                        #standardize=FALSE,
                                                        standardize=TRUE,
                                                        #standardize=FALSE,
                                                        plot_heatmap=TRUE, 
                                                        plot_scatter=TRUE
)))

# put back original feature names
for (feat in seq_along(fits$results$feature)){
  fits$results$feature[feat] <- taxa_names(ps)[make.names(taxa_names(ps)) == 
                                                 fits$results$feature[feat]]
}

input_metadata = input_metadata[!is.na(input_metadata$Case_status),]
input_metadata = input_metadata[!is.na(input_metadata$Sex),]
input_metadata = input_metadata[!is.na(input_metadata$Age),]
input_metadata = input_metadata[!is.na(input_metadata$smoke),]
input_metadata = input_metadata[!is.na(input_metadata$drink),]
input_metadata = input_metadata[!is.na(input_metadata$BMI),]

ps = phyloseq(otu_table(ps),sample_data(ra.ps.s))
sample_data(ps) = data.frame(sample_data(ps))

res <- data.frame()
for (var in seq_along(unique(fits$results$metadata))){
  # get variable name
  var.name <- unique(fits$results$metadata)[var]
  if (length(table(sample_data(ps)[,var.name])) == 2){
    group.1.index <- sample_data(ps)[,var.name] == 
      names(table(sample_data(ps)[,var.name]))[2]
    group.1.index[is.na(group.1.index)] <- FALSE
    group.2.index <- sample_data(ps)[,var.name] == 
      names(table(sample_data(ps)[,var.name]))[1]
    group.2.index[is.na(group.2.index)] <- FALSE
    n1 <- colSums(otu_table(ps)[group.1.index,] > 0)
    n2 <- colSums(otu_table(ps)[group.2.index,] > 0)
    mean1 <- colMeans(otu_table(ps)[group.1.index,])
    mean2 <- colMeans(otu_table(ps)[group.2.index,])
  }else{
    n1 <- rep(sum(table(sample_data(ps)[,var.name])), ntaxa(ps))
    names(n1) <- taxa_names(ps)
    n2 <- rep(NA, ntaxa(ps))
    names(n2) <- taxa_names(ps)
    mean1 <- colMeans(otu_table(ps))
    mean2 <- rep(NA, ntaxa(ps))
    names(mean2) <- taxa_names(ps)
  }
  # calculate fold change and confidence interval of fold change
  if(length(table(sample_data(ps)[,var.name])) == 2){
    FC <- 2^(fits$results$coef[fits$results$metadata == var.name])
    FC.lower <- c()
    FC.upper <- c()
    for (coef in seq_along(fits$results$coef[fits$results$metadata == var.name])){
      FC.lower <- c(FC.lower, 2^(ci(fits$results$coef[fits$results$metadata == 
                                                        var.name][coef],
                                    fits$results$stderr[fits$results$metadata == 
                                                          var.name][coef])['lower.ci']))
      FC.upper <- c(FC.upper, 2^(ci(fits$results$coef[fits$results$metadata == 
                                                        var.name][coef],
                                    fits$results$stderr[fits$results$metadata ==
                                                          var.name][coef])['upper.ci']))
    }
  }else{
    FC <- NA
    FC.lower <- NA
    FC.upper <- NA
  }
  # summarize results for variable
  correction = "BH"
  rvar <- data.frame(Variable=var.name,
                     Feature=fits$results$feature[fits$results$metadata == var.name],
                     N1=n1[fits$results$feature[fits$results$metadata == var.name]],
                     N2=n2[fits$results$feature[fits$results$metadata == var.name]],
                     Mean1=mean1[fits$results$feature[fits$results$metadata == var.name]],
                     Mean2=mean2[fits$results$feature[fits$results$metadata == var.name]],
                     Beta=fits$results$coef[fits$results$metadata == var.name],
                     SE=fits$results$stderr[fits$results$metadata == var.name],
                     P=fits$results$pval[fits$results$metadata == var.name],
                     FDR=p.adjust(fits$results$pval[fits$results$metadata == var.name], 
                                  method=correction),
                     FC=FC, FC_lower=FC.lower, FC_upper=FC.upper,
                     check.names=FALSE)
  res <- rbind(res, rvar[order(rvar$P),])
  # add untested features if they exist
  if (nrow(rvar) != ntaxa(ps)){
    res <- rbind(res,
                 data.frame(Variable=var.name,
                            Feature=taxa_names(ps)[!(taxa_names(ps) %in% 
                                                       fits$results$feature[fits$results$metadata == var.name])],
                            N1=n1[taxa_names(ps)[!(taxa_names(ps) %in% 
                                                     fits$results$feature[fits$results$metadata == var.name])]],
                            N2=n2[taxa_names(ps)[!(taxa_names(ps) %in% 
                                                     fits$results$feature[fits$results$metadata == var.name])]],
                            Mean1=mean1[taxa_names(ps)[!(taxa_names(ps) %in% 
                                                           fits$results$feature[fits$results$metadata == var.name])]],
                            Mean2=mean2[taxa_names(ps)[!(taxa_names(ps) %in% 
                                                           fits$results$feature[fits$results$metadata == var.name])]],
                            Beta=NA, SE=NA, P=NA, FDR=NA, FC=NA, FC_lower=NA, FC_upper=NA,
                            check.names=FALSE)
    )
  }
}
lm.s.npc = list(result.summary=res, Maaslin2.output=fits)

write.csv(lm.s.npc[["result.summary"]], paste0(opts$output, 'MaAsLin2_overall_difference.csv'))


#### Enriched or Depleted ####
# get FDR q-values ready for plotting
plot.data <- lm.s.npc$result.summary[lm.s.npc$result.summary$Variable == 'Group',
                                     c('Feature','P','FDR','FC')]
plot.data <- plot.data[rowSums(is.na(plot.data)) == 0,]

plot.data$`NPC association` <- ifelse(plot.data[,2] < 0.05,
                                      ifelse(plot.data[,4] > 1, 'depleted',
                                             ifelse(plot.data[,4] < 1, 
                                                    'enriched','opposite directions')),
                                      'not associated')

write.csv(plot.data, paste0(opts$output, 'MaAsLin2_enriched_depleted.csv'))

